/* Copyright (c) 2011-2016, EPFL/Blue Brain Project
 * All rights reserved. Do not distribute without permission.
 * Responsible Author: Cyrille Favreau <cyrille.favreau@epfl.ch>
 *
 * This file is part of BRayns
 */

#ifndef RENDERINGPARAMETERS_H
#define RENDERINGPARAMETERS_H

#include <brayns/common/types.h>

#include "AbstractParameters.h"


namespace brayns
{

class AbstractParameters;

/** Manages rendering parameters
 */
class RenderingParameters : public AbstractParameters
{
public:
    RenderingParameters( );

    /** @copydoc AbstractParameters::parse */
    bool parse( int argc, const char **argv) final;

    /** @copydoc AbstractParameters::print */
    void print( ) final;

    /** OSPRay module */
    const std::string& getModule( ) const { return _module; }

    /** OSPRay renderer */
    const std::string& getRenderer( ) const { return _renderer; }

    /** Shadows */
    bool getShadows( ) const { return _shadows; }
    void setShadows( const bool value ) { _shadows = value; }

    /** Softs Shadows generated by randomizing light source position */
    bool getSoftShadows( ) const { return _softShadows; }
    void setSoftShadows( const bool value ) { _softShadows = value; }

    /** Ambient occlusion */
    float getAmbientOcclusionStrength( ) const
    {
        return _ambientOcclusionStrength;
    }
    void setAmbientOcclusionStrength( const float value )
    {
        _ambientOcclusionStrength = value;
    }

    /** Geometry shaded by light sources. No shading coupled with ambient
     * occlusion gives great results!
     */
    bool getLightShading( ) const { return _lightShading; }
    void setLightShading( const bool value ) { _lightShading = value; }

    /** Number of samples per pixel */
    size_t getSamplesPerPixel( ) const { return _spp; }
    void setSamplesPerPixel( const size_t value )
    {
        _spp = value;
    }

    /** Electron shading defined by dot product between surface normal and
     * camera position
     */
    bool getElectronShading( ) const { return _electronShading; }
    void setElectronShading( const bool value)
    {
        _electronShading = value;
    }

    /** Enables photon emission according to the radiance value of the
     * material */
    bool getLightEmittingMaterials( ) const { return _lightEmittingMaterials; }
    void setLightEmittingMaterials( const bool value )
    {
        _lightEmittingMaterials = value;
    }

    /** Enables depth of field by randomizing the camera position */
    bool getDepthOfField( ) const { return _dof; }
    void setDepthOfField( const bool value ) { _dof = value; }

    /** Defines the strength of the camera position randomization */
    float getDepthOfFieldStrength( ) const { return _dofStrength; }
    void setDepthOfFieldStrength( const float value )
    {
        _dofStrength = value;
    }

    /** Enables a gradient background going from black to the "bgcolor"
     * renderer attribute
     */
    bool getGradientBackground( ) const { return _gradientBackground; }
    void setGradientBackground( const bool value )
    {
        _gradientBackground = value;
    }

    const Vector3f& getBackgroundColor( ) const { return _backgroundColor; }
    void setBackgroundColor( const Vector3f& value )
    {
        _backgroundColor = value;
    }

    /**
       Defines the maximum distance between intersection and surrounding
       geometry for touch detection rendering
    */
    float getDetectionDistance( ) const { return _detectionDistance; }
    void setDetectionDistance( const float value )
    {
        _detectionDistance = value;
    }

    /**
       Defines if touch detection applies if the material of the surrounding
       geometry is different from the one of the intersection
    */
    bool getDetectionOnDifferentMaterial( ) const
    {
        return _detectionOnDifferentMaterial;
    }
    void setDetectionOnDifferentMaterial( const bool value )
    {
        _detectionOnDifferentMaterial = value;
    }

    /**
       Near color used by touch detection renderer
    */
    const Vector3f& getDetectionNearColor( ) const
    {
        return _detectionNearColor;
    }
    void setDetectionNearColor( const Vector3f& value )
    {
        _detectionNearColor = value;
    }

    /**
       Far color used by touch detection renderer
    */
    const Vector3f& getDetectionFarColor( ) const { return _detectionFarColor; }
    void setDetectionFarColor( const Vector3f& value )
    {
        _detectionFarColor = value;
    }

    /**
        Raytracers have to deal with the finite precision of computer
        calculations. Since the origin of the reflected ray lies on the surface
        of the object, there will be an intersection point at zero distance.
        Since we do not want that, all intersection distances less than the
        epsilon value are ignored.
     */
    float getEpsilon() const
    {
        return _epsilon;
    }
    void setEpsilon( const float epsilon )
    {
        _epsilon = epsilon;
    }

protected:
    std::string _module;
    std::string _renderer;
    float _ambientOcclusionStrength;
    bool _dof;
    float _dofStrength;
    bool _electronShading;
    bool _gradientBackground;
    bool _lightShading;
    bool _lightEmittingMaterials;
    size_t _spp;
    bool _shadows;
    bool _softShadows;
    Vector3f _backgroundColor;
    float _detectionDistance;
    bool _detectionOnDifferentMaterial;
    Vector3f _detectionNearColor;
    Vector3f _detectionFarColor;
    float _epsilon;
};

}
#endif // RENDERINGPARAMETERS_H
